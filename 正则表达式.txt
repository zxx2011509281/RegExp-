 正则表达式
   1、 元字符
	元字符是正则表达式的基础，比如\d--[0-9]数字字符，\D--[^0-9]非数字字符；还有转义符\f--换页，\n--换行；边界^--字符串起始位置,$--字符串结束位置，量词*--重复零次或更多 x>=0，+--重复一次或更多次 x>=1，?--重复零次或一次  x=(0||1)
{n}n次x=n，{n,}	重复n次或更多  x>=n，{n,m} 重复出现的次数比n多但比m少 n<=x<=m

   2、正则方法
        -> test
            语法: <regexp>.test( string ) -> boolean
            判断这个字符串是否符合这个正则表达式
            常用与验证
        -> exec
            语法: <regexp>.exec( string ) -> Array
            将匹配到的提取出来.
            1> 单个字符串提取
                /e/.exec( 'abcdefg' ) -> [ 'e' ]
                /h/.exec( 'abcdefg' ) -> null
            2> 提取并解析( 常用 )
                分组: 在 正则表达式中使用 () 可以将匹配的结果进行分组. 
                学会分组的编号.
                    1) 从左往右数 左圆括号 (
                    2) 依次从 1 开始给 圆括号编号
                     123  4   5  6
                    /(((.)(.))(.)(.))/
                使用 exec 方法返回的是一个数组. 在匹配的结果中, 匹配到的字符串是数组的 第 0 个元素.
                其中的每一组对应于数组的每一项.
                    var r = /(((.)(.))(.)(.))/;
                    var str = 'abcd';
                    r.exec( str );

                    // [ 0 ]: 匹配到的结果:   'abcd'
                    // [ 1 ]: 匹配到的第1组:  'abcd'
                    // [ 2 ]: 匹配到的第2组:  'ab'
                    // [ 3 ]: 匹配到的第3组:  'a'
                    // ...
		Array[7]={0: "abcd",1: "abcd",2: "ab",3: "a",4: "b",5: "c",6: "d"}
                
                对路径的解析:
                    /.:.*\\.+\..+/
                    例如: c:\windows\system32\1.mp3
			.代表任意字符（C盘） : 对应盘符冒号 .*0次或多次 尽量多的匹配（贪婪模式） 所以从后面开始看
			.+1次或多次 再往前\.转移字符.对应.mp3的"."  所以最后的.+对应mp3
			再往前.+ 1次或多次  再往前\\转移字符\ 对应\1.mp3的"\"，所以 .+对应1
			最后中间的\windows\system32都属于.* 


                    // 贪婪模式, 所有 +, * 这类元字符都是尽可能多匹配
                    /(.+)(.+)(.+)/
			/(.+)(.+)(.+)/.exec('abcdef')结果是
				Array[4]={0: "abcdef"，1: "abcd"，2: "e"，3: "f"}

                    
                    // 取消贪婪使用 ?
                    /(.+?)(.+)(.+)/
			/(.+?)(.+)(.+)/.exec('abcdef')结果是
				Array[4]={0: "abcdef"，1: "a"，2: "bcde"，3: "f"}
                    


            3> 循环提取所有
                'abcdefgedgedg' // 将其中所有的 e 取出来
                操作:
                1) 在正则表达式中启用全局模式: /..../g, new RegExp( '...', 'g' )
                2) 调用一次 exec 方法, 获取一个匹配项
                3) 再次调用 exec 方法, 获得下一个匹配项
                4) 如此往复, 没有匹配项的是否返回 null, 再次调用 exec 则匹配返回第一个匹配项

                var m;
                while ( ( m = r.exec( str ) ) != null ) {
                    // m 就是每一次匹配到的结果
                }

        -> replace
		找出匹配项替换掉
		a、简单的替换：
			'adCde'.replace(/[A-Z]/g,-)------"ad-de"
		b、带回调函数的替换
			'abCdeFg'.replace(/[A-Z]/g,function(str){return str.toLowerCase()})----"abcdefg"
			在这里也可以用分组的思想解决部分难题：比如将'abc-def-ghi-jk'转换为'abcDefGhiJk';
			我们需要去掉'-'还需要将之后的第一个字母变为大写；那我们可以这样
			'abc-def-ghi-jk'.replace(/-(.)/g,function(_,num1){return num1.toUpperCase()})---"abcDefGhiJk"
			这里参数和上面exec方法中的分组一样,"_"代表匹配的结果(由于不需要所有给_)，num1代表匹配到第一组，而且里面只有一个组(.)横线后的任意字母,返回值将字母转换为大写即可；
			再看看，如果同样的字符串我们需要把横线后第二个字母改为下划线"_"，我们可以这样
			'abc-def-ghi-jk'.replace(/(-.)(.)/g,'$1_')----"abc-d_f-g_i-j_"
				在这里有需要注意的"$1"表示匹配到的第一个组，"$2"表示匹配到的第二个组；
			


				